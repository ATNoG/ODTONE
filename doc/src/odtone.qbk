[/==============================================================================
 / Brief   : ODTONE Base Documentation
 / Authors : Carlos Guimaraes <cguimaraes@av.it.pt>
 / Authors : Bruno Santos     <bsantos@av.it.pt>
 /------------------------------------------------------------------------------
 / ODTONE - Open Dot Twenty One
 /
 / Copyright (C) 2009-2012 Universidade Aveiro
 / Copyright (C) 2009-2012 Instituto de Telecomunicações - Pólo Aveiro
 /
 / This software is distributed under a license. The full license
 / agreement can be found in the file LICENSE in this distribution.
 / This software may not be copied, modified, sold or distributed
 / other than expressed in the named license agreement.
 /
 / This software is distributed without any warranty.
 /=============================================================================]

[article ODTONE
    [quickbook 1.5]
    [version 0.4]
    [authors [Guimarães, Carlos]]
    [authors [Santos, Bruno]]
    [copyright 2009-2012 Universidade Aveiro]
    [copyright 2009-2012 Instituto de Telecomunicações - Pólo Aveiro]
    [license
        This software is distributed under a license. The full license
		agreement can be found in the LICENSE in this distribution.
		This software may not be copied, modified, sold or distributed
		other than expressed in the named license agreement.

		This software is distributed without any warranty.
    ]
    [source-mode c++]
]

[section:intro Introduction]

[h3 What is this?]

ODTONE stands for Open Dot Twenty ONE and it is an open-source implementation of
the Media Independent Handover framework from the IEEE 802.21 Media Independent
Handover Services standard, using C++ APIs.

[h3 What does it do?]

ODTONE supplies the implementation of a MIHF, supporting its inherent services
(Media Independent Event Service (MIES), Media Independent Command Service (MIIS)
and Media Independent Command Service (MICS), as well as supporting mechanisms
(Capability Discovery, MIHF Registration, Event Registration, etc.).
It also provides a set of APIs to enable ODTONE users to implement their own
MIH-Users and Link SAPs and to interface with ODTONE's MIHF.

[h3 What differences can be found regarding other IEEE 802.21 implementations?]

ODTONE aims to implement a MIHF that is capable of being deployed in multiple
operating systems. In a first stage, it will support GNU/Linux, followed by
Microsoft NT-based operating systems and others. This means this implementation
will be decoupled of highly dependent operating system mechanisms.

[h3 What does this mean?]

ODTONE's implementation aims to provide a MIHF that will work as a base for user's
scenarios and which will enable the users to implement their own MIH_SAP and
MIH_LINK_SAP. ODTONE provides a simple and flexible interface for the
development of these SAPs, handling MIH Protocol messages and state transitions.

[h3 How can I contribute?]

As was previously mentioned, ODTONE focuses on the MIHF and API's that will
enable users to implement their own MIH_SAP and MIH_LINK_SAP. This means that
it will be entirely up to the user to implement their MIH-Users and LINK technology
support. We would be more than happy to known about your work on these matters!

[h3 Changes in this release]

For changes from the previous release, please have a look at the
[link odtone.changelog Changelog] section.


[endsect]

[section:getStart Getting Started]

[h1 Installation]

As ODTONE is developed to work in several platforms, we won't provide
detailed tutorials for each mainstream operating system. We
will rather present the main guidelines for installing ODTONE and any relevant
notes on specific platforms that might prove an obstacle.

[h3 1. Required Dependencies]

In order to correctly use ODTONE, you must first make sure that you have the
required dependencies:

* *Boost Developer libraries (v1.48)*

[h4 1.1. Boost Quick Guide]
Boost is required to compile ODTONE, so in order to correctly use ODTONE
you must first make sure you have the Boost libraries sources and Boost.Build
installed in your system.

*Download the Boost library(v1.48) [@http://www.boost.org/ boost's website]
and unpack it. We recommend that you unpack it in a project directory next to
odtone.

[teletype]``
projects/
    |
    +-- boost_1_48_0/
    |
    +-- odtone/
``

#Install Boost.Build (if your already have it, skip this step).
To compile the Boost.Build engine, you can use the bootstrap script from the
Boost library sources and then you can copy the resulting binary (b2) to a proper
place (within your $PATH). To finish the Boost.Build installation,
you must tell Boost.Build engine where to find the remaining of Boost.Build. To do
it, you can setup a boost-build.jam file in a parent directory relative to the
odtone root. Example:

[table Setup boost-build.jam
    [
        [boost-build.jam]
        [``
#==============================================================================
# Put this file at the root directory of your project or in any of its parent
# directories. Replace 'path-to-boost' with the path to the boost libraries
# sources.
#
# See the Boost.Build documentation for more details!
#==============================================================================

boost-build path-to-boost/tools/build/v2 ;
        ``]
    ]
]

*To install Boost.Build got to 'boost_1_48_0/tools/build/v2/'. On unix like
systems run './bootstrap.sh' and then 'sudo ./b2 install'.
On windows like systems run 'bootstrap.bat' and then 'b2 install'.

To compile ODTONE go to 'odtone' and run 'b2'.

[important Consult the Boost.Build documentation for more details]

[h3 2. Getting ODTONE]

[*In a tarball]

You can get the ODTONE source code tarball from our
[@http://helios.av.it.pt/projects/odtone/files project page].
Then just unpack it and you are ready to compile and install ODTONE.

[*From the git repository]

You can create your own local copy of the ODTONE by cloning the git repository from
[@http://helios.av.it.pt/projects/odtone/repository ODTONE repository].

*[*Username:] user
*[*-- No password]


To clone the git repository you must run the next command:
``
	git clone https://user@helios.av.it.pt/git/odtone/ odtone
``

[h3 3. Compiling ODTONE]

Once you have obtained the ODTONE source code and have assured that you have
the right dependencies you can compile it. ODTONE does not require any special
procedures or layout for installation.

[table Platform Support
    [[]        [x86-32]                 [x86-64]                 [ARM]]
    [[Linux]   [[$./images/check.png]]  [[$./images/check.png]]  [[$./images/check.png]] ]
    [[Windows] [[$./images/check.png]]  [[$./images/check.png]]  [[$./images/interrogation.png]]  ]
]

[note *For Linux*

We recommend GCC. Most distributions already come with the necessary
pre-requisites, you may additionally need to install g++.

If you get link errors relative to undefined pthread symbols, this means
that your compiler does not link to pthreads by default. You can either pass
the "[~linkflags=-lpthread]" option to bjam. Or, you can also configure the
toolset to link to this library, set "[~using gcc : : : <linkflags>-lpthread ;]"
without quotes at your user-config.jam.
]

[note *For Windows*

We recommend MSVC. You will need to download and install the latest Windows
SDK. This already comes with all pre-requisite libraries and toolchains.]

[note *For Android*

Android Bionic headers have several missing definitions for sockets and
networking, this makes ODTONE impossible to compile with the Android SDK.
However, since Android is based on linux, it is possible to compile ODTONE with
the CodeSourcery GNU Toolchain for ARM Processors, at the expense of a bigger
binary, since we have to link all libraries statically. The target must be
arm-none-linux-gnueabi.

Prebuild binaries are available at
[@http://www.codesourcery.com/sgpp/lite/arm CodeSourcery]

In order to setup user-config.jam for Android, you must add the following line
(without quotes):

"[~using gcc : android	: path-to-toolset/arm-none-linux-gnueabi-g++ : <linkflags>"-Wl,--whole-archive -lpthread -Wl,--no-whole-archive -lc" ;]"

To use the Android toolset, pass the command line option "[~toolset=gcc-android]"
while compiling.


The Android SDK has the necessary tools to run, debug and deploy the ODTONE
binaries.]

[important By default, only the MIHF, the MIH-User and the Link SAP used in the
demo are compiled. However, you can compile the remaining entities by defining their path
during the compilation process.

Here is an example on how to compile ICMP Link SAP: "b2 app/link_sap_icmp/"

[*Path of each entity provided by ODTONE:]

*[*MIHF:] src/mihf/

*[*Client:] app/client/

*[*MIH-User:] app/mih_usr/

*[*MIIS RDF Server:] app/miis_rdf_server/

*[*DHCP-User:] app/dhcp_usr/

*[*DNS-User:] app/dns_usr/

*[*Link SAP:] app/link_sap/

*[*ICMP LINK SAP:] app/link_sap_icmp/

*[*Dummyserver:] src/dummyserver/

]

[h3 4. Generate Doxygen Documentation]
As a supplement to this documentation, it is possible to generate incode documentation.
This can be done using Doxygen, which parses the sources and generates the documentation.
Doxygen uses a configuration file to determine all of its settings.

To simplify the creation of a configuration file, Doxygen can create a template
configuration file for you. To do this call Doxygen from the command line with
the -g option:

	doxygen -g <config-file>

To generate the documentation you can enter:

	doxygen <config-file>


[heading ODTONE User Guide]

[h4 Configuration]

[*ODTONE-MIHF]

The MIHF can be configured based on a set of parameters, which can be
configured either using an configuration file or passing them directly
in the command line. The available configurable parameters are presented
next:

``
	MIHF Configuration Options:
	   --help                                Display configuration options
	   --conf.file arg (=odtone.conf)        Configuration file
	   --conf.recv_buff_len arg (=4096)      Receive buffer length
	   --mihf.id arg (=mihf)                 MIHF ID
	   --mihf.ip arg (=127.0.0.1)            MIHF IP
	   --mihf.remote_port arg (=4551)        Remote MIHF communication port
	   --mihf.local_port arg (=1025)         Local SAPs communication port
	   --mihf.peers arg                      List of peer MIHFs
	   --mihf.users arg                      List of local MIH-Users
	   --mihf.links arg                      List of local Links SAPs
	   --mihf.transport arg (=udp, tcp)      List of supported transport protocols
	   --mihf.link_response_time arg (=3000) Link SAP response time (milliseconds)
	   --mihf.link_delete arg (=2)           Link SAP response fails to forget
	   --mihf.discover arg                   MIHF Discovery Mechanisms Order
	   --enable_broadcast                    Allows broadcast messages
	   --enable_unsolicited                  Allows unsolicited discovery
	   --log arg (=1)                        Log level [0-4]
``

[note
All configurable parameters are self-explained and, therefore,
we will only mention those that are more complex to configure.

[*List of peer MIHFs:] Comma separated list of remote MIHF's.

Usage: mihf.peers = <mihf id> <ip> <port> <list of supported transport protocols>, ...

[*List of local MIH-Users:] Comma separated list of local MIH-User SAP.

Usage: mihf.users = <user sap id> <port> [supported commands> <supported queries>\], ...

[*List of local Link SAPs:] Comma separated list of local MIH Link SAPs.

Usage: mihf.links = <link sap id> <port> <techonoly type> <interface>, ...

[*List of suppoted transport protocols:] Comma separed list of the
transport protocols available. For now UDP and TCP protocols are supported.

Usage: mihf.transport = <udp/tcp>, ...

]

[*SAP's]
``
	MIH Usr Configuration:
	   --help                           Display configuration options
	   --conf.file arg (=mih_usr.conf)  Configuration file
	   --conf.recv_buff_len arg (=4096) Receive buffer length
	   --conf.port arg (=1234)          Listening port
	   --user.id arg (=user)            MIH-User ID
	   --user.commands arg              MIH-User supported commands
	   --mihf.ip arg (=127.0.0.1)       Local MIHF IP address
	   --mihf.local_port arg (=1025)    Local MIHF communication port
	   --dest arg                       MIHF destination
``

[note
All configurable parameters are self-explained and, therefore,
we will only mention those that are more complex to configure.

[*List of supported events:] Comma separated list of the MIH-Users supported commands.

Usage: command = <command 1>, <command 2>, (...), <command N>

]



``
	MIH Link SAP Configuration:
	     --help                           Display configuration options
	     --conf.file arg (=link_sap.conf) Configuration file
	     --conf.recv_buff_len arg (=4096) Receive buffer length
	     --link.id arg (=link)            Link SAP ID
	     --link.port arg (=1235)          Listening Port
	     --link.tec arg                   Technology type
	     --link.link_addr_list arg        Interface address
	     --link.event_list arg            List of supported events
	     --link.command_list arg          List of supported commands
	     --mihf.ip arg (=127.0.0.1)       Local MIHF IP
	     --mihf.id arg (=local-mihf)      Local MIHF ID
	     --mihf.local_port arg (=1025)    Local MIHF communication port
``

[note
All configurable parameters are self-explained and, therefore,
we will only mention those that are more complex to configure.

[*Technology type:] Network interface card technology.
Supported values: GSM, GPRS, EDGE, 802.3, Other, 802_11, CDMA2000, UMTS,
CDMA2000-HRPD, 802_16, 802_20, 802_22.

Usage: tec = <NIC technology>

[*Interface Address:] Network interface card address.

Usage: link_addr = <interface address>

[*List of supported events:] Comma separated list of the Link SAP's supported events.

Usage: event_list = <link event 1>, <link event 2>, (...), <link event N>

[*List of supported events:] Comma separated list of the Link SAP's supported commands.

Usage: command_list = <link command 1>, <link command 2>, (...), <link command N>

]

[h4 Local Demo]

The local demo consists in a simple experiment to demonstrate message
exchanging between the MIHF, the MIH-User and the Link SAP. It allows you to see
how events are generated by the Link SAP and then reported to a MIH-User
that subscribed to those events.

[$./images/local_demo.png]

[*Configuration]

In order to properly run the local demo you will need to edit the default
Link SAP configuration in order to identify the interface
that it will manage (['tec] and ['link_addr] parameters).

[*Running Demo]

The best way to run this demo is to open 3 terminals.
On the first terminal you must start ODTONE-MIHF and on another terminal
you must start the Link SAP. You can see that, at Link SAP bootstrap, the Link SAP
will register itself with its the local MIHF. Now it's time to start the
MIH-User with the configurable parameter ['--dest mihf1],
on your remaining terminal. The ['--dest] option tells the MIH-User to set
the MIHF destination field of the message to mihf1.

If all went well, the MIH-User has requested for the capabilities of the
local MIHF and printed out some information about the discovered interfaces
(those that you previously configured on the Link SAP). For each discovered
interface, the MIH-User will subscribe to all supported events. Now you can
trigger some events by just disconnecting, disabling or shutting down
your network cable/interface or wireless card (according to what you
configured). You can see that the event notifications are propagated from
the Link SAP to the MIH-User.

[h4 Remote Demo]

The remote demo shows the ability of a MIH-User to obtain
event notifications that happen on a Link SAP located on another machine.
You are required to have two machines for this experiment. The first machine
will host an ODTONE-MIHF (mihf1) and the MIH-User, while the second will host
an ODTONE-MIHF (mihf2) and the Link_SAP.

[$./images/remote_demo.png]

[*Configuration]

Autonomous remote MIHF discovery is not taken in consideration,
so you need to configure the remote MIHF's IP addresses, port and supported
transport protocols on each one of the MIHFs. Edit the ODTONE-MIHF
configuration file and add an entry to peers MIHFs in the form:

	<mihf_id> <ip> <port> <list of supported transport protocols>

[note You need to edit the configuration file on both machines]

The mihf1 configuration file must look like:
``
	[mihf]
	id = mihf1
	local_port = 1025
	remote_port = 4551
	peers = mihf2 <mihf2_IP_address> 4551 udp
	transport = udp
``

The mihf2 configuration file must look like:
``
	[mihf]
	id = mihf2
	local_port = 1025
	remote_port = 4551
	peers = mihf1 <mihf1_IP_address> 4551 udp
	transport = udp
``

[note If you are using an Android emulator, the web traffic is routed through your
development machine. So, the IP address assigned to Android emulator is the IP
address of your machine. The development machine can be reached from Android
emulator through 10.0.2.2.]

[*Running Demo]

On the machine that host the mihf2 you must start a terminal and run ODTONE-MIHF.
Then, on another terminal you must start the Link SAP. On the machine that host
the mihf1 you must start a terminal and run ODTONE-MIHF. Then, on another 
terminal you must start the MIH-User with the configurable parameter
['--dest mihf2]. The ['--dest] option tells the MIH-User to set the MIHF
destination field of the frame to mihf2.

Now, like in the local demo, you can trigger some events by just disconnecting,
disabling or shutting down your network cable/interface or wireless card
(according to what you configured). You can see that the event notifications
are propagated from the Link SAP to the MIH-User.

[endsect]

[section:mihf_internals ODTONE MIHF internals]

[section Internal Communications use UDP sockets on loopback interface]

Internal communications refers to the communications between the MIHF
and local SAPs (MIH-users and Link SAPs). ODTONE uses UDP sockets binded
to the loopback interface (127.0.0.1) for exchanging messages between
these entities.

[endsect]

[section MIH confirm messages must set the opcode to 0 (zero)]

Chapter 7 of the MIH standard defines the primitives that should be supported
by an implementation. These primitives show how a SAP can interact with a MIHF.

Chapter 8, of the same standard, defines the message MIH protocol messages for
remote communications (communications between MIHFs).

The ODTONE implementation uses the messages defined on chapter 8 to implement
the primitives of chapter 7.

Please note that the MIHF sends confirm messages to the MIH-Users and response
messages to the remote MIHFs. The MIH protocol allocates 16 bits for the
MIH message ID, where two of those bits are for the opcode.
The opcode defines if a message is a request, response or indication.
So, with 2 bits we can encode four values, where three are already taken.
This leaves 1 available combination for the missing confirm
primitives. Confirm primitives set the opcode to 0 (zero).

[endsect]


[section Multiple Link SAP support]

With the assumption that each Link SAP manages a single network interface, it was
necessary to ODTONE to support multiple Link SAP. So, when a new request is received at
the MIHF and whose destination is a Link SAP, the MIHF processes it and redirects
the request to the proper Link SAP, based on the information collected by the
local discovery mechanism and the information presented on the request
message.

However, there are cases where the destination could be a set of Link SAPs.
In those cases, the MIHF sends a message to all destinations Link SAPs and waits
a time interval for all the responses of the Link SAPs. After that time, the MIHF
processes all received responses from Link SAPs and sends the response to the requestor.

[note The time that the MIHF waits for all responses can be configured in the
MIHF (configuration file or command line).]

[endsect]


[section Remote Link SAP support]

Since the MIHF allows the storage of the IP address of the Link SAPs, the
Link SAPs attached to the MIHF can be on the same machine or not, i.e., the Link SAPs
can be local or remote.

Although the communications are made between two different machines, to the MIHF
the remote Link SAP is always seen as a local entity and therefore, the messages received
from local and remote Link SAPs are processed equally. This behaviour is possible because
ODTONE uses sockets to provide local communications.

[$./images/remote_sap.png]

[endsect]

[section Event subscribe/unsubscribe optimization]

In order to optimize the process of subscription/unsubscription of events at
the MIHF, the number of messages between the local entities
(i.e., between the MIHF and Link SAPs.) was reduced. When a MIH-User requests
for an event subscription, if a subscription has been made previously by other
entity, the MIHF subscribes the MIH-User and immediately replies to it, otherwise the MIHF
firstly tries to subscribe the event with the Link SAP or the peer MIHF.

The method to optimize the unsubscription mechanism is similar to
the subscription one and it aims for the same objectives. When a MIH-User
requests to unsubscribe an event in a Link SAP the MIHF unsubscribes it
locally. The MIHF unsubscribes the event with the Link SAP or the peer
MIHF only if the event has no more subscriptions.

[$./images/subscribe.png]

[endsect]

[section MIH Primitives mapped in MIH Protocol Messages]

ODTONE uses the MIH protocol to provide communications between the MIHF and local
entities. However, it was verified that some MIH LINK SAP primitives cannot be mapped
in the existing MIH protocol messages so, it was necessary to define new TLVs that carry the
information presented in these primitives.

The following table show the correspondence between MIH_LINK_SAP primitive and
the new TLVs and its data type:

[table ODTONE specific TLVs
    [
		[MIH_LINK_SAP Primitive]
		[TLV Type Name]
		[TLV Type Value]
		[Data type]
    ]

    [
		[SupportedLinkEventList]
		[tlv_link_evt_list]
		[101]
		[LINK_EVT_LIST]
    ]

    [
		[SupportedLinkCommandList]
		[tlv_link_cmd_list]
		[102]
		[LINK_CMD_LIST]
    ]

    [
		[LinkParametersRequest]
		[tlv_link_parameters_req]
		[103]
		[LIST(LINK_PARAM_TYPE)]
    ]

    [
		[LinkParametersStatusList]
		[tlv_link_parameters_status_list]
		[104]
		[LIST(LINK_PARAM_TYPE)]
    ]

    [
        [LinkStatesRequest]
		[tlv_link_states_req]
		[105]
		[LINK_STATES_REQ]
    ]

    [
        [LinkStatesResponse]
		[tlv_link_states_rsp]
		[106]
		[LIST(LINK_STATES_RSP)]
    ]

    [
        [LinkDescriptorsRequest]
		[tlv_link_descriptor_req]
		[107]
		[LINK_DESC_REQ]
    ]

    [
        [LinkDescriptorsResponse]
		[tlv_link_descriptor_rsp]
		[108]
		[LIST(LINK_DESC_RSP)]
    ]

    [
		[LinkAction]
		[tlv_link_action]
		[109]
		[LINK_ACTION]
    ]

    [
		[LinkActionResult]
		[tlv_link_ac_result]
		[110]
		[LINK_AC_RESULT]
    ]

    [
		[ScanResponseSet]
		[tlv_link_scan_rsp_list]
		[111]
		[LIST(LINK_SCAN_RSP)]
    ]
    
    [
		[LinkDetInfo]
		[tlv_link_det_info]
		[112]
		[LINK_DET_INFO]
    ]

	[
		[InterfaceTypeAddress]
		[tlv_interface_type_addr]
		[113]
		[LINK_ID]
    ]

    [
		[MobilityServicesDiscovery]
		[tlv_mos_dscv]
		[114]
		[MOS_DSCV]
    ]
]

[endsect]

[endsect]


[section:app Applications]

[variablelist

    [[[link odtone.app.mihf_index ODTONE-MIHF]]
    [The MIHF is the central entity of the IEEE 802.21 standard, defined
    as a logical entity whose purpose is to facilitate handover decisions
    to the network selector entity. Its purpose is achieved by providing
    the inputs to higher layers through abstract services and communicating
    with the lower layers of the mobility-management protocol stack through
    technology-specific interfaces. By other words, the MIHF provides
    mechanisms that enable the upper layers to manage and control the
    handover procedure in a media independent way.]]

    [[[link odtone.app.mih_usr_index MIH-User]]
    [The MIH-User specifies a media independent interface between the MIHF and
     upper layers of the mobility management protocol stack. The upper layers need to
     register with the MIHF as users to receive MIHF-generated events and
     link-layer events which are originated at lower layers. MIH-Users
     directly send commands to the local MIHF using the service primitives
     available in the 802.21 standard.]]

    [[[link odtone.app.miis_index MIIS Server]]
    [The MIIS Server provides details about the characteristics and
	services provided by the serving and neighbor networks. The information
	enables effective system access and effective handover decisions.]]

    [[[link odtone.app.dns_usr_index DNS-User]]
    [The DNS-User enables the discovery of PoS entities
	in a given domain using the DNS services (according to the guidelines depicted in the RFC5679).]]

    [[[link odtone.app.dhcp_usr_index DHCP-User]]
    [The DHCP-User enables the discovery of PoS entities by using the DHCP procedures
	(according to the guidelines depicted in the RFC5678).]]

	[[[link odtone.app.link_sap_index Link_SAP]]
	[The Link SAP specifies an abstract media dependent interface between the MIHF
	and the lower layers media-specific protocol stacks of technologies such as IEEE 802.3,
	IEEE 802.11, IEEE 802.16, 3GPP and 3GPP2.]]

    [[[link odtone.app.link_sap_icmp_index ICMP Link SAP]]
    [The ICMP Link SAP allows the attachment detection of another node
	using the ICMP protocol.]]

    [[[link odtone.app.client_index Client]]
    [The ['client] is a simple application that lets you send any message
     to a particular destination. In this way, it is possible to send a specific message
     to a choosen destination in order to test is behaviour easily and quickly.]]

    [[[link odtone.app.dummyserver_index Dummyserver]]
    [The ['dummyserver] is a simple application that, as the name implies, works like
     a dummy server. It is always listening (at port 4000) for incoming messages and
     it outputs them in the console.]]
]

[include app/mihf.qbk]
[include app/mih_usr.qbk]
[include app/miis.qbk]
[include app/dhcp_user.qbk]
[include app/dns_user.qbk]
[include app/link_sap.qbk]
[include app/link_sap_icmp.qbk]
[include app/client.qbk]
[include app/dummyserver.qbk]

[endsect]

[section:extensions ODTONE Extensions]

[section Local discovery]

Due to the decoupled architecture of the MIHF and the local entities (i.e. Link SAPs and
MIH-Users), it is necessary to configure these entities in the MIHF in order to know about its
existence. They can be configured statically, by the user, or automatically, using a discovery
mechanism. The static configuration can be very limited, and may fail when, for example, the
MN activates/deactivates an interface or even hot-plugs new ones. However, the IEEE 802.21
standard does not define any mechanism to discover the local entities so, the development of
a novel local discovery procedure is required, allowing the MIHF to discover its Link SAPs
and MIH-Users and their capabilities in a dynamic way. Thus, local discovery refers to the
procedure that allows the MIHF to discover its Link SAPs and their capabilities, as well as
its MIH-Users.


[*Link SAP Discovery]

[$./images/Internal_link_discovery.png]

The local discovery mechanisms implemented on ODTONE enables the discovery and
management of the available Link SAPs. Thus, Link SAPs discovery is divided
in three main phases: the registration, SAP availability and SAP unavailability.

In the registration phase, the MIHF is permanently
listening for incoming messages from the Link SAPs at a fixed port. When a Link SAP
becomes active, it locally sends a "Link_Register.indication" message
to the MIHF indicating its intention to register
with the MIHF. This message carries information about the Link SAP, including its
ID, listening port, link layer technology and link address. Next, the MIHF requests the Link
SAP for its capabilities by sending a "Link_Capability_Discover.request" message. This
process is repeated for all Link SAPs in order to provide the MIHF with the full capabilities
belonging to that node.

[note
Because there is no primitive/message in the 802.21 standard that allows the Link
SAP to send the register information to the MIHF, the "Link_Register.indication"
message was created. This message allows the Link SAP to send informations
to the MIHF about which technology supports and which interface it manages.
Associated with the creation of this new message type was also created a new
TLV type named “Interface Type Addr TLV” whose correspondent data type is a “LINK_ID”.

[$./images/link_register_indication_message.png]
]

The second phase is availability and, as the name implies,
deals with the Link SAP availability, i.e., the MIHF must be able to detect the active presence
of the Link SAP. So, when the MIHF receives a response or an event notification from the
Link SAP, it detects the Link SAP as active.

Finally, the third phase deals with SAP unavailability.
When the MIHF does not receive a response from a Link SAP, the Link SAP must be
considered as inactive or unresponsive. The MIHF must, therefore, initiate the procedures to
update its local capabilities.

[note The waiting time interval for response message and how many fail responses
can occur before the MIHF forget Link SAP can be defined at the MIHF configuration file.]

[*MIH User Discovery]

[$./images/Internal_user_discovery.png]

The process of discovering MIH-Users implemented on ODTONE is based on a
registration process of the MIH-User with the MIHF. When the MIH-User becomes active,
it locally sends a "User_Register.indication" message to the MIHF, including
information about its listening port, supported commands and/or supported queries.

Upon the reception of the "User_Register.indication" message, the MIHF learns about the
MIH-User and the communications between them can start normally.

[note
	Because there is no primitive/message in the 802.21 standard that allows MIH-User
	to send register information to the MIHF the “User_Register.indication” message was
	created. This message allows the MIH-Users to send informations
	to the MIHF about the supported commands and/or queries.

	[$./images/user_register_indication_message.png]
]

[endsect]

[section Remote discovery]
The remote discovery mechanisms involve the discovery of peer MIHFs and its
capabilities. This is known as MIHF discovery and it can be achieved by using
L2 or L3 discovery mechanisms. It allows a MN to discover 802.21-enabled
network entities and vice-versa, as well as a network entity to discover
each other. In addition, by combining it with the MIH Capability Discover
procedure, it is possible to find out the capabilities of the discovered
entities, i.e., the services provided by them.

The ODTONE implementation provides L3 mechanisms which enable the remote
discovery. It can be achieved by using the MIH Capability Discover procedure
defined in the IEEE 802.21 standard and/or mechanisms that involve using DHCP
and DNS services. Compared with the standard architecture of the IEEE 802.21, the node has two new
components: DHCP and/or DNS users. These are seen as MIH-enabled entities of the upper
layers (i.e., MIH-Users) with which the MIHF interacts to request the discovery
of available PoS. The DNS-User and the DHCP-User are then responsible for directly
communicate with the respective server, in order to discover PoS entities and
to obtain associated transport information.

[$./images/l3_arch.png]

[note The DNS-User and DHCP-User are working only for Linux environment. However, you can
implement your own discovery entities with guidelines defined as follows.]

The MIH protocol does not support the necessary mechanisms to carry the
information about the discovered entities. Therefore, a new optional TLV type was created
and added to the MIH_Capability_Discover messages of the base ODTONE implementation.
Consequently, a new data type was defined as well.

[$./images/mos_dscv.png]

The MOS_DSCV data type carries the discovered PoS divided by service type. Each PoS is
identified by an instance of the MOS_INFO data type, which carries information about its ID,
IP address and listening port.

The L3 discovery mechanisms can be enabled by configuring in the MIHF the list of discovery
entities. The order by which they are configured defines the order by which the
entities will be requested for discovering PoS. For example, if no entity is configured with
discovery role, the discovery mechanisms will not be enable and therefore, the discovery
mechanisms are the default ones, i.e., it is only possible to discover entities by multicasting
MIH Capability Discover messages as defined in the IEEE 802.21 standard. Otherwise, the
discovery mechanisms are enabled and, upon the receiving of a discovery request, the MIHF
invokes the first discovery entity configured. By receiving the discovery results, the MIHF
checks if all necessary information about the PoS was discovered and, based on that, decides
to complement it with other discover mechanism or to initiate the MIH Capability exchange
procedure.

The discovery entities retrieve the discovered information to the MIHF divided by services,
i.e., for each service the MIHF receives a list of available PoS, which are individually requested
for its capabilities. However, with this approach, if a given PoS provides more than one
service it appears in more than one list and therefore, it is requested more than once for its
capabilities. To avoid this repetition the MIHF tracks the requested PoS and, if it detects a
repeated one it drops the request.


[section Scenarios]

The following figures represents the discovery scenarios using the DNS and DHCP services
provided by ODTONE.

[section DHCP]
[$./images/dhcp_disc.png]
[endsect]

[section DHCP bootstrap]
[$./images/dhcp_boot_disc.png]
[endsect]

[section DNS]
[$./images/dns_disc.png]
[endsect]

[section DHCP + DNS]
[$./images/dhcp_dns_disc.png]
[endsect]

[section DHCP bootstrap + DNS]
[$./images/dhcp_boot_dns_disc.png]
[endsect]

[endsect]

[endsect]


[section MIH-Users and Link SAPs configuration]

One of the extensions provided by the ODTONE is a mechanism which allows the MIH-Users
or the Link SAPs to dynamically register with the MIHF, named
[link odtone.extensions.local_discovery local discovery].

However this mechanism is optional and, therefore, the statically configuration of the
MIH-Users and Link SAPs is still possible. In this section we will depict the many
ways to configure the MIH-Users and Link SAPs.

[h4 MIH-Users configuration]

[*Using the local discovery mechanism]

You just need to configure in the MIH-User configuration file the following options:
``
	##
	## Commands supported by the MIH-User
	## e.g.: commands = mih_link_get_parameters, mih_link_configure_thresholds
	##
	commands = <comma separated list of supported commands>

	##
	## Queries supported by the MIH-User
	## e.g: queries = iq_type_binary_data, iq_type_rdf_data
	##
	queries = <comma separated list of supported queries>
``

[*Statically configuration on the MIHF]

You need to configure in the ODTONE-MIHF configuration file the following options:
``
	##
	## Comma separated list of local MIH User SAPs id's and ports
	## e.g.1: users = user 1234
	## e.g.2: users = user 1234 mih_net_ho_candidate_query iq_type_binary_data
	## e.g.3: users = user 1234 iq_type_binary_data
	##
	users = <user sap id> <port> [<supported commands> <supported queries>], ...
``

[note As presented on the previous example, the MIH-User can be configured in many
ways. If the supported commands are not configured (e.g.1 and e.g.3) the MIHF will assume
that the MIH-User supports all commands. However, this behaviour does not work
for the supported queries, since its MIIS specific. In this way, if the supported
queries are not configured (e.g.1) the MIHF will assume that the MIH-User does not
support any query.

Also, the configuration of the supported commands and supported queries can be
specified (e.g.2) and, therefore, the MIHF will assume that the MIH-User only
supports the configured commands and queries.]

[h4 Link SAPs configuration]

[*Using the local discovery mechanism]

You just need to configure in the Link SAP configuration file the following options:
``
	##
	## Link SAP interface technology
	## e.g.: tec = 802_11
	##
	tec = <interface>

	##
	## Link SAP interface address
	## e.g.: link_addr = 00:11:22:33:44:55
	##
	link_addr = <interface address>
``

[*Statically configuration on the MIHF]

You need to configure in the ODTONE-MIHF configuration file the following options:
``
	##
	## Comma separated list of local MIH Link SAPs id's and ports.
	## e.g.: links = link 1235 802_11 00:11:22:33:44:55
	##
	links = <link sap id> <port> <technology type> <interface>, ...
``

[note In what concerns technology type, the MIHF only supports Ethernet, IEEE 802.11,
IEEE 802.16, IEEE 802.20, IEEE 802.22 configuration.]

[h4 Deactivate local discovery]

By default the MIH-Users and Link SAPs provided by ODTONE have the local
discovery enabled, i.e., at the bootstrap they send a registration message to their
local MIHF. If you want to deactivate this behaviour you need to comment the following
lines in the correspondent constructor:

[*MIH-User]
``
	odtone::mih::message m;
	boost::optional<odtone::mih::mih_cmd_list> supp_cmd = parse_supported_commands(cfg);

	m << odtone::mih::indication(odtone::mih::indication::user_register)
		& odtone::mih::tlv_command_list(supp_cmd);
	m.destination(odtone::mih::id("local-mihf"));

	_mihf.async_send(m, boost::bind(&mih_user::user_reg_handler, this, boost::cref(cfg), _2));
``

[*MIIS RDF Server]
``
	odtone::mih::message m;
	boost::optional<odtone::mih::iq_type_list> supp_iq = parse_supported_queries(cfg);

	m << odtone::mih::indication(odtone::mih::indication::user_register)
	    & odtone::mih::tlv_query_type_list(supp_iq);
	m.destination(odtone::mih::id("local-mihf"));

	_mihf.async_send(m, boost::bind(&miis_rdf_server::user_reg_handler, this, boost::cref(cfg), _2));
``

[*Link SAP]
``
	init();
``

[*Link SAP ICMP]
``
	register_local_mihf();
``

[endsect]


[section MIH Protocol C interface]
The MIH Protocol C interface was developed and provided to us by [@http://www.eurecom.fr/en Eurecom],
in Sophia-Antipolis, France. These libraries
provide the necessary definitions of the messages and datatypes used to communicate
with ODTONE's MIHF (using a local version of the MIH Protocol). As such, with this
valuable contribution from Eurecom, users of the ODTONE implementation are able to
create their MIH-Users and Link SAP modules using the C language.

You can find it on "extensions/MIH_C_Protocol/" folder.

For more information please contact: davide.brizzolara@eurecom.fr or
michelle.wetterwald@eurecom.fr

Together with the MIH Protocol C interface, some software that can be used to test
the MIH Protocol C interface was provided. It consists in two entities:

* a MIH-User Test (you can find it on "extensions/MIH_C_Protocol/mih_usr" folder);
* a LTE Link SAP Test, named mRALlteInt (you can find it on
"extensions/MIH_C_Protocol/LTE_link_Test" folder).

[h4 Installation]

The mRALlteInt is compiled and installed in the mRALlteInt folder
("extensions/MIH_C_Protocol/LTE_link_Test/mRALlteInt"). To compile it you just
need to run the following command:
``
make
``

The mih_usr and odtone-mihf executables will be available by compiling ODTONE.

[note The mih-usr.cpp file provided must replace the default mih-usr.cpp provided
by ODTONE in order to run the LTE Link SAP test Interface Scenario
([link odtone.extensions.mih_protocol_c_interface.test_scenario depicted here]).]

[h4 Test scenario]

Messages are exchanged between the following entities:
``
 mih_usr <-> ODTONE <-> mRALlteInt
``

The test scenario is depicted in the following figure:

[$./images/MIH_C_test_scenario.jpg]

To test the validation scenario, execute the following programs, each in its own
terminal, and in the following order:
``
   ./odtone-mihf
   ./mRALlteInt <LOG_location> <LOG_level>
   ./mih_usr --dest=mihf1
``

[note
 mRALlteInt usage :

 ./mRALlteInt <LOG_location> <LOG_level>

 LOG_location can take the following values
 0 : Log to screen
 1 : Log to file (default is /tmp/log_MT_LTE.txt)
 2 : Log to system (syslog) -- FFS

 If no value is entered, default value as log to file is assumed.

 LOG_level can take the following values
 0 : DEBUG + ERROR
 1 : ERROR only
]

[endsect]


[section Sensor SAPs Support]

[section Introduction]

Wireless Sensor Networks are an important and exciting research area: using
automated sensing mechanisms can help in many situations ranging from health,
security, leisure and others. However, there is a great number of different
sensor makers with their different specific mechanisms and parameters.
Instituto de Telecomunicações, Aveiro, Portugal, have developed a MIH Sensor
SAP having as base our ODTONE 802.21 implementation. This MIH Sensor SAP
provides abstraction mechanisms towards all sensor technologies, facilitating
Wireless Sensor Network operations and adding new sensing events and parameters
which can further even more an optimized handover decision in mobility-supporting
networks.

In this walkthrough we will demonstrate how to install, setup, deploy and run
the Sensor SAP demo released on the ODTONE 0.4 version using SunSPOTs.

[endsect]

[section Requirements]

* Latest ODTONE version installed.
* Java Open JDK 6 or later
* Netbeans with SunSPOT Plugin
* SunSPOTs with Yellow SDK version installed

[endsect]

[section Instalation]

In the "extensions/sensors" folder you will find:

* [*0001-PATCH-Sensor-support.patch]: this file contains the changes to the MIHF and the MIH
Protocol to support sensors. You can apply it by running the ['git am <path-to-patch>].
* [*Dummy_Sensor_SAP]: this folder contains the Dummy Sensor SAP Netbeans project.

[endsect]

[section Configuration]

The ODTONE-MIHF configuration file:
``
	[mihf]
	id = mihf1
	local_port = 1025
	remote_port = 4551
	peers = mihf2 0.0.0.0 4552 udp
	users = user 1234
	links = sensor_sap 1235 Sensor sensoraddress
	transport = udp
``

[endsect]

[section Step-by-Step]

#Connect the SunSPOT Basestation to your computer.

#Make sure you have connectivity between your computer and the SunSPOT
by opening the SpotManager and on the Sun SPOTs tab, click Refresh and
make sure that in the dropdown list you basestation’s MAC address is
selected.

#Open the Netbeans IDE, go to File, Open Project and browse to the
folder where you have your copy of the Dummy Sensor SAP. The NetbeansIDE
should immediately recognize it as a Netbeans project so you should be
able to select it and click “Open Project”. The Dummy Sensor SAP project
is now open in your Netbeans IDE Projects navigator (at the left side of
the IDE by default)

#With your mouse’s right button click on top of the Dummy Sensor SAP project
and click on “Run”.

#The Dummy Sensor SAP is now being deployed to your Basestation and as soon
as it is ready it will automatically run itself.

#Now go to the ODTONE’s MIHF folter (../ODTONE/dist/odtone-mihf) and
start the MIHF.

#You can now run the Dummy Sensor MIH-User (../ODTONE/dist/mih_sensor_usr)
and execute the demo.

[endsect]

[section Technical Walkthrough]

The MIH User will subscribe the Sensor SAP for some events ([*A]), then it
is going to configure some threshold values ([*B]), obtain current operation
parameters ([*C]), request that an action be performed ([*D]), and then receive
two events ([*E] and [*F]) for which it had subscribed to.

[$./images/sensor_scenario.png]

[h4 Event Subscription (A)]
- In this message the TLV Parameter “RequestedMIHEventList” is configured so
that Sensor_UP and Link_Parameter_Report events are subscribed.

[h4 Threshold Configuration (B)]
- The threshold configuration is set to trigger an action when the value of
25 (not specified the type of sensor) is crossed above threshold.

[h4 Operation Parameters (C)]
- This message allows the user to retrieve the operation mode of the sensors.

[h4 Actions (D)]
- The Link actions message will request that the sensor returns a message with
the sensor present readings.

[h4 Events (E and F)]
- These events are related to the subscription performed in (A).

[endsect]

[section Publications]

* Marcelo Lebre, Daniel Corujo, Diogo Gomes, Rui L. Aguiar,
"Context Transport Based on 802.21", Proc. 1 CNRS 2011 - Conference on Wireless
Sensor Networks, Coimbra, Portugal, Mar 2011

* Daniel Corujo, Marcelo Lebre, Diogo Gomes, Rui L. Aguiar,
"Media Independent Transport Service for Ambient Intelligence", Proc. 2011
Conferência sobre Redes de Computadores, Coimbra, Portugal, Nov 2011

* Daniel Corujo, Marcelo Lebre, Diogo Gomes, Rui L. Aguiar,
"A Framework for Flexible Sensor Information Dissemination", Proc. 2nd
International Workshop on Interconnections of Wireless Sensor Networks,
Barcelona, Spain, Jun 2011

* Daniel Corujo, Marcelo Lebre, Diogo Gomes, Rui L. Aguiar, "Sensor Context
Information for Energy-Efficient Optimization of Wireless Procedures ", Proc.
22nd IEEE International Symposium on Personal, Indoor and Mobile Radio
Communications (PIMRC), Toronto, Canada, Sep 2011

* Daniel Corujo, Marcelo Lebre, Diogo Gomes, Rui L. Aguiar, "A Framework for
the Connectivity of an Internet of Things", Proc. IEEE Sensors, Special
Session: Ambient Intelligence Technologies & Applications Session, Limerick,
Ireland, Oct 2011

[endsect]

[endsect]

[endsect]


[section:library Libraries]

[variablelist
    [[ODTONE Base] [
    The ODTONE BASE library contains a set of classes which offers several helper
	mechanisms (such as debug, list management, log, exceptions and random values
    generation) to facilitate the information management.]]

    [[ODTONE MIH] [
    The ODTONE MIH library defines all MIH data types presented in the 802.21
    standard. In addition, it provides a set of classes which facilitates
    the creation and parsing of MIH messages.]]

    [[ODTONE SAP] [
    The ODTONE SAP library contains a set of I/O service classes, providing the ability
    to send and receive MIH messages. The implementation is based on the
    boost::asio and it only supports asynchronous operation.
    [*Note:] It is important to be familiar with the boost::asio library.
    It is also recommend to be familiar with boost::function and
    boost::bind.]]

    [[ODTONE NET] [
	The ODTONE NET library defines a set of classes which offer several network
	protocols and terminology support.]]
]

[xinclude ../odtone_base_lib.xml]
[xinclude ../odtone_mih_lib.xml]
[xinclude ../odtone_sap_lib.xml]
[xinclude ../odtone_net_lib.xml]

[endsect]

[section:changelog Changelog]

[*ODTONE 0.4 - Open Dot Twenty ONE.]

* Fixed wrong LINK_CMD_LIST, LINK_EVENT_LIST, MIH_CMD_LIST and MIH_EVENT_LIST
data type definition.
	* If your SAPs make use of any of these data types you should have to update
them ([link odtone.changelog.data_types_changes see more info below]).
* Redefinition of the interface used by MIH-Users to register themselves with
the local MIHF ([link odtone.changelog.mih_users_registration_changes see more info below]).
* Implementation of mechanisms for discovering remote peer MIHFs:
	* DNS-User: discovery mechanim which uses DNS services;
	* DHCP-User: discovery mechanim which uses DHCP services.
* Response timers: all messages are associated with a timer, which replies
with a failure message in case of timeout.
* Provision of a new Link SAP example: this new Link SAP uses the ICMP protocol
to detect the attachment of another node.
* Definition of new messages in the client application.
* Provision of a new library named NET library: it defines a set of classes
which offer several network protocols and terminology support.
* Several bug-fixes.
* Fix compilation with more recent gcc version.
* ODTONE documentation revision.


[h4 Data types changes]
In the ODTONE 0.4 release was redefined the LINK_CMD_LIST, LINK_EVENT_LIST, MIH_CMD_LIST and MIH_EVENT_LIST
that were not in accordance with the standard.

[important Implementations of MIH-Users and Link_SAP modules using the LINK_CMD_LIST, LINK_EVENT_LIST,
MIH_CMD_LIST and/or MIH_EVENT_LIST datatypes need to change their code, in order for it to work
with the new changes. Take into consideration that this is necessary for absolute
interoperability with the standard.]

[*Data type definitions on ODTONE 0.3 and earlier]
``
/**
 * The enumeration of MIH_EVENT_LIST and LINK_EVENT_LIST data type.
 */
enum event_list_enum {
        link_detected = 0,             /**< Link detected.             */
        link_up = 1,                   /**< Link up.                   */
        link_down = 2,                 /**< Link down.                 */
        link_parameters_report = 3,    /**< Link parameters report.    */
        link_going_down = 4,           /**< Link doing down.           */
        link_handover_imminent = 5,    /**< Link handover imminent.    */
        link_handover_complete = 6,    /**< Link handover complete.    */
        link_pdu_transmit_status = 7,  /**< Link PDU transmit status.  */
};

/**
 * MIH_EVENT_LIST and LINK_EVENT_LIST data type.
 */
typedef bitmap<32, event_list_enum> event_list;

///////////////////////////////////////////////////////////////////////////////
/**
 * The enumeration of MIH_CMD_LIST and LINK_CMD_LIST data type.
 */
enum command_list_enum {
        link_get_parameters = 0,       /**< Link get parameters.           */
        link_configure_thresholds = 1, /**< Link configure thresholds.     */
        link_actions = 2,              /**< Link actions.                  */
        net_ho_candidate_query = 3,    /**< NET handover candidate query.  */
        net_ho_commit = 3,             /**< NET handover commit.           */
        n2n_ho_query_resources = 3,    /**< N2N handover query resources.  */
        n2n_ho_commit = 3,             /**< N2N handover commit.           */
        n2n_ho_Complete = 3,           /**< N2N handover complete.         */
        mn_ho_candidate_query = 4,     /**< MN handover candidate query.   */
        mn_ho_commit = 4,              /**< MN handover commit.            */
        mn_ho_complete = 4,            /**< MN handover complete.          */
};

/**
 * MIH_CMD_LIST and LINK_CMD_LIST data type.
 */
typedef bitmap<32, command_list_enum> command_list;

``

[*Data type definitions on ODTONE 0.4]
``
/**
 * MIH_CMD_LIST data type enumeration.
 */
enum mih_cmd_list_enum {
	mih_cmd_link_get_parameters = 0,        /**< Link get parameters.           */
	mih_cmd_link_configure_thresholds = 1,  /**< Link configure thresholds.     */
	mih_cmd_link_actions = 2,               /**< Link actions.                  */
	mih_cmd_net_ho_candidate_query = 3,     /**< NET handover candidate query.  */
	mih_cmd_net_ho_commit = 3,              /**< NET handover commit.           */
	mih_cmd_n2n_ho_query_resources = 3,     /**< N2N handover query resources.  */
	mih_cmd_n2n_ho_commit = 3,              /**< N2N handover commit.           */
	mih_cmd_n2n_ho_complete = 3,            /**< N2N handover complete.         */
	mih_cmd_mn_ho_candidate_query = 4,      /**< MN handover candidate query.   */
	mih_cmd_mn_ho_commit = 4,               /**< MN handover commit.            */
	mih_cmd_mn_ho_complete = 4,             /**< MN handover complete.          */
};

/**
 * MIH_CMD_LIST data type.
 */
typedef bitmap<32, mih_cmd_list_enum> mih_cmd_list;

/**
 * MIH_EVT_LIST data type enumeration.
 */
enum mih_evt_list_enum {
	mih_evt_link_detected = 0,              /**< Link detected.             */
	mih_evt_link_up = 1,                    /**< Link up.                   */
	mih_evt_link_down = 2,                  /**< Link down.                 */
	mih_evt_link_parameters_report = 3,     /**< Link parameters report.    */
	mih_evt_link_going_down = 4,            /**< Link doing down.           */
	mih_evt_link_handover_imminent = 5,     /**< Link handover imminent.    */
	mih_evt_link_handover_complete = 6,     /**< Link handover complete.    */
	mih_evt_link_pdu_transmit_status = 7,   /**< Link PDU transmit status.  */
};

/**
 * MIH_EVT_LIST data type.
 */
typedef bitmap<32, mih_evt_list_enum> mih_evt_list;

/**
 * LINK_CMD_LIST data type enumeration.
 */
enum link_cmd_list_enum {
	cmd_link_event_subscribe      = 1,  /**< Event subscribe.       */
	cmd_link_event_unsubscribe    = 2,  /**< Event unsubscribe.     */
	cmd_link_get_parameters       = 3,  /**< Get parameters.        */
	cmd_link_configure_thresholds = 4,  /**< Configure thresholds.  */
	cmd_link_action               = 5,  /**< Action.                */
};

/**
 * LINK_CMD_LIST data type.
 */
typedef bitmap<32, link_cmd_list_enum> link_cmd_list;

/**
 * LINK_EVT_LIST data type enumeration.
 */
enum link_evt_list_enum {
	evt_link_detected = 0,              /**< Link detected.             */
	evt_link_up = 1,                    /**< Link up.                   */
	evt_link_down = 2,                  /**< Link down.                 */
	evt_link_parameters_report = 3,     /**< Link parameters report.    */
	evt_link_going_down = 4,            /**< Link doing down.           */
	evt_link_handover_imminent = 5,     /**< Link handover imminent.    */
	evt_link_handover_complete = 6,     /**< Link handover complete.    */
	evt_link_pdu_transmit_status = 7,   /**< Link PDU transmit status.  */
};

/**
 * LINK_EVT_LIST data type.
 */
typedef bitmap<32, link_evt_list_enum> link_evt_list;
``

Due to this changes the definition of two new TLVs were necessary, in order to
exchanges of LINK_CMD_LIST and LINK_EVENT_LIST data types between the MIHF and
the Link SAPs.

[table TLVs for LINK_CMD_LIST and LINK_EVENT_LIST
    [
		[MIH_LINK_SAP Primitive]
		[TLV Type Name]
		[TLV Type Value]
		[Data type]
    ]

    [
		[SupportedLinkEventList]
		[tlv_link_evt_list]
		[101]
		[LINK_EVT_LIST]
    ]

    [
		[SupportedLinkCommandList]
		[tlv_link_cmd_list]
		[102]
		[LINK_CMD_LIST]
    ]
]

[h4 MIH-Users registration changes]
The message used by the MIH-Users to register with the MIHF has been modified in
order to specifically define which commands and queries it supports. In this way,
the MIHF can properly forward the messages to the MIH-Users. Check
[link odtone.extensions.local_discovery this] for more info about the local
discovery.

[*MIH_User_Register.indication definition on ODTONE 0.3]

[$./images/user_register_indication_message_old.png]

[*MIH_User_Register.indication definition on ODTONE 0.4]

[$./images/user_register_indication_message.png]


[*Changes in the code]

ODTONE 0.3:

``
	// For the MIH-User
	odtone::mih::message m;

	m << odtone::mih::indication(odtone::mih::indication::user_register)
	    & odtone::mih::tlv_mbb_handover_support(true);

	// ----- || -------
	// For the MIIS
	odtone::mih::message m;

	m << odtone::mih::indication(odtone::mih::indication::user_register)
	    & odtone::mih::tlv_mbb_handover_support(false);
``

ODTONE 0.4:

``
	// For the MIH-User
	odtone::mih::message m;
	boost::optional<odtone::mih::mih_cmd_list> supp_cmd = parse_supported_commands(cfg);

	m << odtone::mih::indication(odtone::mih::indication::user_register)
	    & odtone::mih::tlv_command_list(supp_cmd);

	// ----- || -------
	// For the MIIS
	odtone::mih::message m;
	boost::optional<odtone::mih::iq_type_list> supp_iq = parse_supported_queries(cfg);

	m << odtone::mih::indication(odtone::mih::indication::user_register)
	    & odtone::mih::tlv_query_type_list(supp_iq);
``

[note The MIH-User provided by ODTONE was modified in order to parse the supported
commands from the configuration file. The MIIS provided by ODTONE was modified in
order to parse the supported queries from the configuration file.]

[note In the MIHF configuration file you can configure which commands and queries
a given MIH-User supports. If nothing is specified it assume that the MIH-User
supports all commands but it does not support any query.]

[endsect]

[section:license License]
[h4 GNU LESSER GENERAL PUBLIC LICENSE]

[h5 Version 3, 29 June 2007]

Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.

This version of the GNU Lesser General Public License incorporates
the terms and conditions of version 3 of the GNU General Public
License, supplemented by the additional permissions listed below.

[h6 0. Additional Definitions.]

As used herein, "this License" refers to version 3 of the GNU Lesser
General Public License, and the "GNU GPL" refers to version 3 of the GNU
General Public License.

"The Library" refers to a covered work governed by this License,
other than an Application or a Combined Work as defined below.

An "Application" is any work that makes use of an interface provided
by the Library, but which is not otherwise based on the Library.
Defining a subclass of a class defined by the Library is deemed a mode
of using an interface provided by the Library.

A "Combined Work" is a work produced by combining or linking an
Application with the Library.  The particular version of the Library
with which the Combined Work was made is also called the "Linked
Version".

The "Minimal Corresponding Source" for a Combined Work means the
Corresponding Source for the Combined Work, excluding any source code
for portions of the Combined Work that, considered in isolation, are
based on the Application, and not on the Linked Version.

The "Corresponding Application Code" for a Combined Work means the
object code and/or source code for the Application, including any data
and utility programs needed for reproducing the Combined Work from the
Application, but excluding the System Libraries of the Combined Work.

[h6 1. Exception to Section 3 of the GNU GPL.]

You may convey a covered work under sections 3 and 4 of this License
without being bound by section 3 of the GNU GPL.

[h6 2. Conveying Modified Versions.]

If you modify a copy of the Library, and, in your modifications, a
facility refers to a function or data to be supplied by an Application
that uses the facility (other than as an argument passed when the
facility is invoked), then you may convey a copy of the modified
version:

[*a)] under this License, provided that you make a good faith effort to
ensure that, in the event an Application does not supply the
function or data, the facility still operates, and performs
whatever part of its purpose remains meaningful, or

[*b)] under the GNU GPL, with none of the additional permissions of
this License applicable to that copy.

[h6 3. Object Code Incorporating Material from Library Header Files.]

The object code form of an Application may incorporate material from
a header file that is part of the Library.  You may convey such object
code under terms of your choice, provided that, if the incorporated
material is not limited to numerical parameters, data structure
layouts and accessors, or small macros, inline functions and templates
(ten or fewer lines in length), you do both of the following:

[*a)] Give prominent notice with each copy of the object code that the
Library is used in it and that the Library and its use are
covered by this License.

[*b)] Accompany the object code with a copy of the GNU GPL and this license
document.

[h6 4. Combined Works.]

You may convey a Combined Work under terms of your choice that,
taken together, effectively do not restrict modification of the
portions of the Library contained in the Combined Work and reverse
engineering for debugging such modifications, if you also do each of
the following:

[*a)] Give prominent notice with each copy of the Combined Work that
the Library is used in it and that the Library and its use are
covered by this License.

[*b)] Accompany the Combined Work with a copy of the GNU GPL and this license
document.

[*c)] For a Combined Work that displays copyright notices during
execution, include the copyright notice for the Library among
these notices, as well as a reference directing the user to the
copies of the GNU GPL and this license document.

[*d)] Do one of the following:

[*i)] Convey the Minimal Corresponding Source under the terms of this
License, and the Corresponding Application Code in a form
suitable for, and under terms that permit, the user to
recombine or relink the Application with a modified version of
the Linked Version to produce a modified Combined Work, in the
manner specified by section 6 of the GNU GPL for conveying
Corresponding Source.

[*ii)] Use a suitable shared library mechanism for linking with the
Library.  A suitable mechanism is one that (a) uses at run time
a copy of the Library already present on the user's computer
system, and (b) will operate properly with a modified version
of the Library that is interface-compatible with the Linked
Version.

[*e)] Provide Installation Information, but only if you would otherwise
be required to provide such information under section 6 of the
GNU GPL, and only to the extent that such information is
necessary to install and execute a modified version of the
Combined Work produced by recombining or relinking the
Application with a modified version of the Linked Version. (If
you use option 4d0, the Installation Information must accompany
the Minimal Corresponding Source and Corresponding Application
Code. If you use option 4d1, you must provide the Installation
Information in the manner specified by section 6 of the GNU GPL
for conveying Corresponding Source.)

[h6 5. Combined Libraries.]

You may place library facilities that are a work based on the
Library side by side in a single library together with other library
facilities that are not Applications and are not covered by this
License, and convey such a combined library under terms of your
choice, if you do both of the following:

[*a)] Accompany the combined library with a copy of the same work based
on the Library, uncombined with any other library facilities,
conveyed under the terms of this License.

[*b)] Give prominent notice with the combined library that part of it
is a work based on the Library, and explaining where to find the
accompanying uncombined form of the same work.

[h6 6. Revised Versions of the GNU Lesser General Public License.]

The Free Software Foundation may publish revised and/or new versions
of the GNU Lesser General Public License from time to time. Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.

Each version is given a distinguishing version number. If the
Library as you received it specifies that a certain numbered version
of the GNU Lesser General Public License "or any later version"
applies to it, you have the option of following the terms and
conditions either of that published version or of any later version
published by the Free Software Foundation. If the Library as you
received it does not specify a version number of the GNU Lesser
General Public License, you may choose any version of the GNU Lesser
General Public License ever published by the Free Software Foundation.

If the Library as you received it specifies that a proxy can decide
whether future versions of the GNU Lesser General Public License shall
apply, that proxy's public statement of acceptance of any version is
permanent authorization for you to choose that version for the
Library.
[endsect]
